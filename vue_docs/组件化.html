<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>组件化 | hhltd的个人博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="前端开发 hhltd的个人博客">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.c36be9e9.js" as="script"><link rel="preload" href="/assets/js/2.34235d8e.js" as="script"><link rel="preload" href="/assets/js/4.f8365012.js" as="script"><link rel="prefetch" href="/assets/js/10.6ce8a8cb.js"><link rel="prefetch" href="/assets/js/11.624e2edb.js"><link rel="prefetch" href="/assets/js/12.e7e1a653.js"><link rel="prefetch" href="/assets/js/13.410548ad.js"><link rel="prefetch" href="/assets/js/14.b5893008.js"><link rel="prefetch" href="/assets/js/15.2d052b5f.js"><link rel="prefetch" href="/assets/js/16.c2f7e181.js"><link rel="prefetch" href="/assets/js/17.6b15aa38.js"><link rel="prefetch" href="/assets/js/18.cf1cb7f5.js"><link rel="prefetch" href="/assets/js/19.d392b7a9.js"><link rel="prefetch" href="/assets/js/20.9732a725.js"><link rel="prefetch" href="/assets/js/3.2f02bfbf.js"><link rel="prefetch" href="/assets/js/5.d117c289.js"><link rel="prefetch" href="/assets/js/6.6b673022.js"><link rel="prefetch" href="/assets/js/7.0b9b5fee.js"><link rel="prefetch" href="/assets/js/8.b011d26d.js"><link rel="prefetch" href="/assets/js/9.e7cae791.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="hhltd的个人博客" class="logo"> <span class="site-name can-hide">hhltd的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js_docs/" class="nav-link">
  JS
</a></div><div class="nav-item"><a href="/css_docs/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/vue_docs/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/node_docs/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/others_docs/" class="nav-link">
  日常
</a></div><div class="nav-item"><a href="https://github.com/hhltd/hhltd.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js_docs/" class="nav-link">
  JS
</a></div><div class="nav-item"><a href="/css_docs/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/vue_docs/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/node_docs/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/others_docs/" class="nav-link">
  日常
</a></div><div class="nav-item"><a href="https://github.com/hhltd/hhltd.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vue_docs/vue3中PropType的作用.html" class="sidebar-link">props types</a></li><li><a href="/vue_docs/组件化.html" class="active sidebar-link">组件化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="组件化"><a href="#组件化" class="header-anchor">#</a> 组件化</h1> <p>在校招述职中, 和评委老师交流了关于组件的知识, 接下来就从前端的组件化开发来聊聊怎样封装一个通用的前端组件</p> <blockquote><p>前端组件化开发, 已经有多年的历史了, 不管是服务端渲染, 还是前端SPA, 都有了比较成熟的组件化开发的方案。随着组件化开发的普及, 前端社区中贡献了很多不错的前端组件, 都提供开箱即用的方案, 使得更好的发挥组件化的优势。前端团队内, 如果有人对前端组件化的理解不够深入, 就不能开发出好的组件, 会给项目的维护带来更大的成本</p></blockquote> <h4 id="什么是前端组件化开发"><a href="#什么是前端组件化开发" class="header-anchor">#</a> 什么是前端组件化开发</h4> <p>你应该遇到过, 将一个页面的几百行, 甚至上千行的代码逻辑写在一个js文件中的情况
通常这种代码都很难读下去, 更别说要维护起来, 添加新功能、移除一些老功能了, 因为你不知道改动一个地方, 会不会出现意想不到的bug
这个时候, 你就需要利用组件化开发, 拆分功能, 封装组件, 单独维护</p> <ul><li>现代化前端框架通常都是实现MVVM的方案, 数据层(M)和视图层(V)相互连接, 同时变更, 使得页面交互保持高度的一致性</li> <li>前端的组件化在概念上与后端的package很相似, 只不过前端的组件涉及到更多的是展示和交互方面的逻辑。当然, 前端组件与后端架构的微服务概念类似, 可以理解成一个组件就是一个服务组件, 只提供某个服务</li> <li>前端组件化开发, 就是将页面的某一部分独立出来, 将这一部分的数据层(M)、视图层(V)和 控制层(C)用黑盒的形式全部封装到一个组件内, 暴露出一些开箱即用的函数和属性供外部组件调用</li> <li>前端组件, 包含了HTML、CSS、JavaScript, 包含了组件的模板、样式和交互等内容, 基本上涵盖了组件的所有的内容, 外部只要按照组件设定的属性、函数及事件处理等进行调用即可, 完全不用考虑组件的内部实现逻辑, 对外部来说, 组件是一个完全的黑盒</li> <li>组件可以多层封装, 通过调用多个小组件, 最后封装成一个大组件, 供外部调用。比如: 一个<strong>Input</strong>输入框是一个组件, 一个<strong>Select</strong>下拉选择框也是一个组件, 可以用form在这两个组件上包装一层, 就是一个<strong>Form</strong>的组件</li> <li>一些比较常用的前端组件, 像 vue-router, vuex, react-router, redux, mobx等, 都是基于Vue和React的组件, 它们只专注于路由、状态存储的工作, 并且把这些事情做好</li></ul> <h4 id="组件化开发的优点"><a href="#组件化开发的优点" class="header-anchor">#</a> 组件化开发的优点</h4> <p>说到底, 前端的组件化开发, 可以很大程度上降低系统各个功能的耦合性, 并且提高了功能内部的聚合性。这对前端工程化及降低代码的维护来说, 是有很大的好处的
耦合性的降低, 提高了系统的伸展性, 降低了开发的复杂度, 提升开发效率, 降低开发成本
组件封装的好, 加班也少了, bug也少了, 就有更多时间喝喝咖啡、打打农药了:)</p> <p><img src="/assets/img/errpic.61f2e8b0.jpeg" alt="" title=":size=440x388"></p> <h4 id="如何设计一个好的组件"><a href="#如何设计一个好的组件" class="header-anchor">#</a> 如何设计一个好的组件</h4> <ol><li>设计原则</li></ol> <ul><li>细粒度的考量</li></ul> <p>在学习设计模式的时候会遇到很多种设计原则, 其中一个设计原则就是单一职责原则, 在组件库的开发中同样适用
我们原则上一个组件只专注一件事情, 单一职责的组件的好处很明显, 由于职责单一就可以最大可能性地复用组件
但是这也带来一个问题, 过度单一职责的组件也可能会导致过度抽象, 造成组件库的碎片化</p> <p>以antd中的autocomplete组件为例, 它其实是由input和select组件组合而成
因此我们完全可以复用之前的相关组件, 同时Calendar、Form等等一系列组件都复用了Select组件, 那么Select的细粒度就是合适的, 因为Select保持的这种细粒度很容易被复用</p> <p><img src="/assets/img/autoc.4fa7c6c0.jpg" alt="" title=":size=394x278"></p> <p>还有一个例子, 一个徽章数组件(Badge), 它的右上角会有红点提示, 可能是数字也可能是icon
它的职责当然也很单一, 这个红点提示也理所当然也可以被单独抽象为一个独立组件, 但是我们通常不会将他作为独立组件, 因为在其他场景中这个组件是无法被复用的
因为没有类似的场景再需要小红点这个小组件了, 所以作为独立组件就属于细粒度过小, 因此我们往往将它作为Badge的内部组件, 比如在antd中它以ScrollNumber的名称作为Badge的内部组件存在</p> <p><img src="/assets/img/bagde.71645d02.jpg" alt="" title=":size=370x126"></p> <p>所以, 所谓的单一职责组件要建立在可复用的基础上, 对于不可复用的单一职责组件我们仅仅作为独立组件的内部组件即可</p> <ul><li>通用性考量
我们要设计的本身就是通用组件, 不同于我们常见的业务组件, 通用组件是与业务解耦但是又服务于业务开发的, 那么问题来了, 如何保证组件的通用性, 通用性高一定是好事吗？</li></ul> <p>比如我们设计一个选择器(Select)组件,通常我们会设计成这样</p> <p><img src="/assets/img/select.558d4fdc.jpg" alt="" title=":size=400x276"></p> <p>这是一个我们最常见也最常用的选择器, 但是问题是其通用性大打折扣</p> <p>当我们有一个需求是长这样的时候, 我们之前的选择器组件就不符合要求了, 因为这个Select组件的最下部需要有一个可拓展的条目的按钮</p> <p><img src="/assets/img/select2.f7416a7a.jpg" alt="" title=":size=478x334"></p> <p>这个时候我们难道要重新修改之前的选择器组件, 甚至再造一个符合要求的选择器组件吗?一旦有这种情况发生, 那么只能说明之前的选择器组件通用性不够, 需要我们重新设计</p> <p>antd的Select组件预留了dropdownRender来进行自定义渲染, 其依赖的rc-select组件中的代码如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span>dropdownRender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">dropdownRender</span><span class="token punctuation">(</span>menuNode<span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Antd依赖了大量以rc-开头的底层组件, 这些组件被react-component团队(同时也就是Antd团队)维护, 其主要实现组件的底层逻辑, Antd则是在此基础上添加Ant Design设计语言而实现的</p></blockquote> <p>当然类似的设计还有很多, 通用性设计其实是一定意义上放弃对DOM的掌控, 而将 DOM 结构的决定权转移给开发者
dropdownRender其实就是放弃对Select下拉菜单中条目的掌控, Antd的Select组件其实还有一个没有在文档中体现的方法getInputElement应该是对Input组件的自定义方法
Antd整个Select的组件设计非常复杂, 基本将所有的DOM结构控制权全部暴露给了开发者, 其本身只负责底层逻辑和最基本的DOM结构</p> <p>具体可以去看一下antd所依赖的re-select最终 jsx的结构, 这里不详细列出来了</p> <p>那么这么多需要自定义的地方, 这个Select组件岂不是很难用?因为好像所有地方都需要开发者自定义
通用性设计在将DOM结构决定权交给开发者的同时也保留了默认结构, 在开发者没有显示自定义的时候默认使用默认渲染结构, 其实 Select 的基本使用很方便,如下:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>  <span class="token operator">&lt;</span>Select defaultValue<span class="token operator">=</span><span class="token string">&quot;zyb&quot;</span> style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> width<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> disabled<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>Option value<span class="token operator">=</span><span class="token string">&quot;zyb&quot;</span><span class="token operator">&gt;</span>zyb<span class="token operator">&lt;</span><span class="token operator">/</span>Option<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Select<span class="token operator">&gt;</span>
</code></pre></div><blockquote><p>组件的形态(DOM结构)永远是千变万化的, 但是其行为(逻辑)是固定的, 因此通用组件的秘诀之一就是将DOM结构的控制权交给开发者, 组件只负责行为和最基本的DOM结构</p></blockquote> <ol start="2"><li>技术选型</li></ol> <ul><li>css解决方案</li></ul> <p>由于css本身的众多缺陷, 如书写繁琐(不支持嵌套)、样式易冲突(没有作用域概念)、缺少变量(不便于一键换主题)等不一而足
为了解决这些问题, 社区里的解决方案也是出了一茬又一茬, 从最早的css prepocessor(SASS、LESS、Stylus)到后来的后起之秀PostCSS, 再到CSS Modules、Styled-Components等</p> <p>antd选择的是less, bootstrap选择的是scss, 这两种方案孰优孰劣已经争论了很多年了, 这里就不详细讲了</p> <p>但是不管是哪种方案都有一个很烦人的点, 就是需要额外引入css, 比如antd需要这样显示引入</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>  <span class="token keyword">import</span> Button <span class="token keyword">from</span> <span class="token string">'antd/lib/button'</span><span class="token punctuation">;</span>
  <span class="token keyword">import</span> <span class="token string">'antd/lib/button/style'</span><span class="token punctuation">;</span> 
</code></pre></div><p>为了解决这种尴尬的情况, antd用Babel插件将这种情况Hack掉了</p> <p>至于最优的方案, 我也没有找到具体的资料, 可能需要视实际的场景而定吧, 可以看一下material-ui库的使用
另外还有styled-components可以了解一下</p> <p>https://zhuanlan.zhihu.com/p/26878157</p> <ul><li>js解决方案</li></ul> <p>啥也别说了, TypeScript走起, 因为巨硬大法好...</p> <h4 id="组件开发项目的搭建"><a href="#组件开发项目的搭建" class="header-anchor">#</a> 组件开发项目的搭建</h4> <ol><li>打包工具</li></ol> <p>市面上打包工具数不胜数, 最火爆的当然是需要配置工程师专门配置的webpack, 但是在类库开发领域它有一个强大的对手就是rollup
作为基础类库的打包工具rollup的优势如下:</p> <ul><li>Tree Shaking: 自动移除未使用的代码, 输出更小的文件</li> <li>Scope Hoisting: 所有模块构建在一个函数内, 执行效率更高</li> <li>Config 文件支持通过 ESM 模块格式书写 可以一次输出多种格式</li> <li>模块规范: IIFE, AMD, CJS, UMD, ESM Development 与 production 版本: .js, .min.js</li></ul> <p>虽然上面部分功能已经被webpack实现了, 但是rollup明显引入得更早, 而Scope Hoisting更是杀手锏
由于webpack不得不在打包代码中构建模块系统来适应app开发(模块系统对于单一类库用处很小), Scope Hoisting将模块构建在一个函数内的做法更适合类库的打包</p> <ol start="2"><li>代码检测</li></ol> <p>啥也不说了, eslint走起</p> <p>市面上最流行的代码检测风格应该是Airbnb出品的eslint-config-airbnb</p> <ol start="3"><li>commit规范</li></ol> <p>目前流行的方案是Angular团队的规范, 其关于head的大致规范如下:</p> <ul><li>type: commit 的类型</li> <li>feat: 新特性</li> <li>fix: 修改问题</li> <li>refactor: 代码重构</li> <li>docs: 文档修改</li> <li>style: 代码格式修改, 注意不是css修改</li> <li>test: 测试用例修改</li> <li>chore: 其他修改, 比如构建流程, 依赖管理</li> <li>scope: commit 影响的范围, 比如: route, component, utils, build...</li> <li>subject: commit 的概述, 建议符合50/72formatting</li> <li>body: commit 具体修改内容, 可以分为多行, 建议符合50/72formatting</li> <li>footer: 一些备注, 通常是BREAKING CHANGE或修复的bug的链接</li></ul> <ol start="4"><li>其它</li></ol> <p>单元测试, 代码美化, 持续集成等等</p> <h4 id="如何设计一个轮播图组件-audio或者video组件"><a href="#如何设计一个轮播图组件-audio或者video组件" class="header-anchor">#</a> 如何设计一个轮播图组件(Audio或者Video组件)</h4> <p>讲了这么多理论知识, 接下来可以动手自己尝试开发一个组件</p> <p>未完待续...</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue_docs/vue3中PropType的作用.html" class="prev">
        props types
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c36be9e9.js" defer></script><script src="/assets/js/2.34235d8e.js" defer></script><script src="/assets/js/4.f8365012.js" defer></script>
  </body>
</html>
